# メモリの安全性とリソース管理とRust
________



### Rustとは

Mozillaによって開発されたシステムプログラミング用の言語
手続き型・関数型・オブジェクト指向をサポートしている。
ゼロコスト抽象化(=オーバーヘッドなしの抽象化)も目標としている。



### とりあえず変数束縛と関数定義


## 変数束縛
```rust
let one: u32 = 1; //再代入不可
let mut one: u32 = 1;//再代入化
let one = 1; //変数宣言では型推論できる
```

## 関数定義

```rust
//仮変数と帰り型の型推論はできない。returnはいらない
fn add(x: u32, y: u32) -> u32 {
    a + b
}
```



## メモリの安全性とは
不正なメモリにアクセスしない事

```cpp
auto user = new User();
delete user;
user.name; // 不正なメモリアクセス!
```


他にも
- 解放したメモリをもう一回解放してしまう
- 確保していないメモリを解放する
- 確保していないメモリにアクセスするとか
- マルチスレッドでのデータ競合など


プログラムが管理していないメモリに対する操作をしないようにする


GCがある言語ならユーザーがメモリの管理しなくてすむので安全
がGCにはオーバーヘッドあるので低レイヤの処理ではなるべく避けたい
とはいえ自分でメモリ管理するのめんどくさい！というかバグりそう


変数のスコープを抜けたらその変数が持っているメモリをコンパイラが解放すればいい！
```rust
{
let one = Box::new(1);
}// free(one); 
```

## 解決策






##まとめ







